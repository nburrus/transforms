<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="jquery.min.js"></script>
<script src="three.min.js"></script>
<script src="OrbitControls.js"></script>
<script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<script src="bootstrap.min.js"></script>

<!-- Generated through https://www.bootstrap-live-customizer.com/ .
     First selecting the Cosmo theme. -->
<link rel="stylesheet" href="bootstrap.min.css">

<style>
  /* Remove the spinner buttons on number input fields */
  
  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
  input[type="number"] {
    -moz-appearance: textfield;
    text-align: center;
  }
  /* Fixed size for our pretty float */
  
  .form-control.prettyFloat {
    display: inline-flex;
    margin-right: 0em;
    width: 6.5em;
  }
  
  .page-header {
    margin-top: 1em;
    margin-bottom: 1em;
  }
  
  .table.packed {
    width: auto;
    margin: 1em auto;
  }
  
  .table.packed td {
    vertical-align: middle;
    padding: 0;
    border: none;
  }
  
  .table.packed td.pr-2 {
    padding-right: 0.2em;
  }
  
  .row {
    background-color: #e2e9e9;
  }
  
  .row.bg-1-2 {
    background-color: #7e9a9a;
  }
  /* This is here to make all the columns have the same height. */
  
  @media only screen and (min-width: 481px) {
    .flex-row.row {
      display: flex;
      flex-wrap: wrap;
    }
    .flex-row.row>[class*='col-'] {
      display: flex;
      flex-direction: column;
    }
    .flex-row.row:after,
    .flex-row.row:before {
      display: flex;
    }
  }
  
  .hide {
    display: none;
  }
  
  .col.bg-1-1 {
    background-color: #e2e9e9;
  }
  
  .col.bg-1-2 {
    background-color: #7e9a9a;
  }
  
  .col.bg-2-1 {
    background-color: #ffebcc;
  }
  
  .col.bg-2-2 {
    background-color: #f6d8ac;
  }
  
  .col.bg-2-1 {
    background-color: #ffb84d;
  }
  
  .col.bg-2-2 {
    background-color: #db9833;
  }
  
  .col.bg-3-1 {
    background-color: #40a5f2;
  }
  
  .col.bg-3-2 {
    background-color: #2a6592;
  }
  
  .col.bg-4-1 {
    background-color: #cce9ff;
  }
  
  .col.bg-4-2 {
    background-color: #8ec3eb;
  }
  
  .help-tip {
    display: inline-block;
    text-align: center;
    background-color: #aaaaaa;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    font-size: 16px;
    line-height: 32px;
    font-weight: bold;
    color: #fff;
    cursor: default;
  }
  
  .help-tip:hover {
    background: #fff;
    color: #aaaaaa;
  }
  
  .webgl-view {
    margin: 1em auto;
  }
</style>

<script type="application/javascript">
  var state = {};
  state.bFromA = new THREE.Matrix4(); // the transform

  let matrixIndex = (r, c) => {
    return c * 4 + r;
  }
  let prettyFloat = (f) => {
    return Math.round(f * 1e5) / 1e5;
  }
  let rad2deg = (v) => {
    return v * 180.0 / Math.PI;
  }
  let deg2rad = (v) => {
    return v * Math.PI / 180.0;
  }

  let updateRotationMatrixView = function() {

    let elmToStr = (row, col) => {
      let v = state.bFromA.elements[matrixIndex(row, col)];
      return prettyFloat(v);
    };

    // Elements are stored in col-major mode, 4x4 matrix.        
    for (let row = 0; row < 3; ++row)
      for (let col = 0; col < 3; ++col) {
        let htmlValue = elmToStr(row, col);
        let htmlId = `#m${row}${col}`;
        $(htmlId).val(htmlValue);
      }
  };

  let updateRotationMatrixVectorConversion = function() {
    let getRow = (rowIndex) => {
      return new THREE.Vector3(state.bFromA.elements[matrixIndex(rowIndex, 0)],
        state.bFromA.elements[matrixIndex(rowIndex, 1)],
        state.bFromA.elements[matrixIndex(rowIndex, 2)]);
    };

    let isPermutationWithEps = (row, eps) => {
      let numZeros = (Math.round(row.x / eps) == 0) +
        (Math.round(row.y / eps) == 0) +
        (Math.round(row.z / eps) == 0);
      return numZeros == 2;
    };

    let isPerfectPermutation = (row) => {
      return isPermutationWithEps(row, 1e-5);
    };

    let approxZeroThreshold = 0.2;

    let isApproxPermutation = (row) => {
      return isPermutationWithEps(row, approxZeroThreshold);
    };

    let row0 = getRow(0);
    let row1 = getRow(1);
    let row2 = getRow(2);

    let allPerfect = (isPerfectPermutation(row0) &&
      isPerfectPermutation(row1) &&
      isPerfectPermutation(row2));

    let allApprox = (isApproxPermutation(row0) &&
      isApproxPermutation(row1) &&
      isApproxPermutation(row2));

    if (!allApprox) {
      $('#matrix-vector-a-from-b').html("not a permutation");
      return;
    }

    let eqOrApproxEq = (allPerfect ? '=' : '\\approx');

    let getNonZeroName = (row) => {
      if (Math.abs(Math.abs(row.x) - 1.0) < approxZeroThreshold)
        return row.x < 0 ? '-X_A' : 'X_A';
      if (Math.abs(Math.abs(row.y) - 1.0) < approxZeroThreshold)
        return row.y < 0 ? '-Y_A' : 'Y_A';
      if (Math.abs(Math.abs(row.z) - 1.0) < approxZeroThreshold)
        return row.z < 0 ? '-Z_A' : 'Z_A';
    };

    let X_B = getNonZeroName(row0);
    let Y_B = getNonZeroName(row1);
    let Z_B = getNonZeroName(row2);

    let formula = $('#matrix-vector-a-from-b');

    formula.html(`$$ [X_B, Y_B, Z_B] ${eqOrApproxEq} [${X_B}, ${Y_B}, ${Z_B}] $$`);
    MathJax.Hub.Queue(["Typeset", MathJax.Hub, formula.get()]);
  }

  let updateEulerView = function() {
    let eulerAngles = new THREE.Euler();
    eulerAngles.setFromRotationMatrix(state.bFromA, 'ZYX');
    $('#euler-x').val(prettyFloat(rad2deg(eulerAngles.x)));
    $('#euler-y').val(prettyFloat(rad2deg(eulerAngles.y)));
    $('#euler-z').val(prettyFloat(rad2deg(eulerAngles.z)));
  };

  let updateQuaternionView = function() {
    let q = new THREE.Quaternion();
    q.setFromRotationMatrix(state.bFromA);
    $('#quaternion-x').val(prettyFloat(q.x));
    $('#quaternion-y').val(prettyFloat(q.y));
    $('#quaternion-z').val(prettyFloat(q.z));
    $('#quaternion-w').val(prettyFloat(q.w));
  };

  let updateAngleAxisView = function() {
    let q = new THREE.Quaternion();
    q.setFromRotationMatrix(state.bFromA);
    let angle = 2.0 * Math.acos(q.w);
    let s = Math.sqrt(1 - q.w * q.w);
    let x, y, z;
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
      // if s close to zero then direction of axis not important
      x = q.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
      y = q.y;
      z = q.z;
    } else {
      x = q.x / s; // normalise axis
      y = q.y / s;
      z = q.z / s;
    }
    $('#angle-axis-x').val(prettyFloat(x));
    $('#angle-axis-y').val(prettyFloat(y));
    $('#angle-axis-z').val(prettyFloat(z));
    $('#angle-axis-theta').val(prettyFloat(rad2deg(angle)));
  };

  let updateViewFrom = function(from) {
    if (from != 'rotationMatrix') updateRotationMatrixView();
    if (from != 'eulerAngles') updateEulerView();
    if (from != 'quaternion') updateQuaternionView();
    if (from != 'angleAxis') updateAngleAxisView();
    updateRotationMatrixVectorConversion();
  };

  let onRotationMatrixChange = function() {
    let floatOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) : 0.0;
    };

    for (let row = 0; row < 3; ++row) {
      for (let col = 0; col < 3; ++col) {
        let htmlId = `m${row}${col}`;
        state.bFromA.elements[matrixIndex(row, col)] = floatOrZero(htmlId);
      }
    }

    updateViewFrom('rotationMatrix');
  };

  let onEulerChange = function() {
    let floatRadiansOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) * Math.PI / 180.0 : 0.0;
    };
    let euler = new THREE.Euler(floatRadiansOrZero("euler-x"), floatRadiansOrZero("euler-y"), floatRadiansOrZero("euler-z"), 'ZYX');
    state.bFromA.makeRotationFromEuler(euler);
    updateViewFrom('eulerAngles');
  };

  let onQuaternionChange = function() {
    let floatOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) : 0.0;
    };
    let q = new THREE.Quaternion(
      floatOrZero("quaternion-x"),
      floatOrZero("quaternion-y"),
      floatOrZero("quaternion-z"),
      floatOrZero("quaternion-w"));
    q.normalize();
    state.bFromA.makeRotationFromQuaternion(q);
    updateViewFrom('quaternion');
  };

  let onAngleAxisChange = function() {
    let floatOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) : 0.0;
    };
    let q = new THREE.Quaternion();
    q.setFromAxisAngle(new THREE.Vector3(
        floatOrZero("angle-axis-x"),
        floatOrZero("angle-axis-y"),
        floatOrZero("angle-axis-z")),
      Math.PI * floatOrZero("angle-axis-theta") / 180.0);
    state.bFromA.makeRotationFromQuaternion(q);
    updateViewFrom('angleAxis');
  };

  let createWebGLScene = function() {
    let scene = new THREE.Scene();
    scene.background = new THREE.Color(0xdddddd);

    let aspectRatio = 4.0 / 3;
    let camera = new THREE.PerspectiveCamera(75, aspectRatio, 0.1, 1000);

    let renderer = new THREE.WebGLRenderer();
    renderer.domElement.classList.add('webgl-view');

    let webglViewElement = $('#webgl-view');
    webglViewElement.append(renderer.domElement);

    let setRenderSize = function() {
      let newWidth = window.innerWidth * 0.9;
      if (newWidth > 800)
        newWidth = window.innerWidth * 0.5;
      renderer.setSize(newWidth, newWidth / aspectRatio);
    };

    $(window).on('resize', function() {
      setRenderSize();
    });

    setRenderSize();

    let geometry = new THREE.BoxGeometry(1, 1, 1);
    let material = new THREE.MeshBasicMaterial({
      color: 0x00aaff
    });
    let cube = new THREE.Mesh(geometry, material);
    scene.add(cube);

    camera.position.z = 2;

    let render = function() {
      renderer.render(scene, camera);
    };

    controls = new THREE.OrbitControls(camera, webglViewElement.get(0));
    controls.addEventListener('change', render);
    controls.enablePan = false;
    controls.enableZoom = false;
    // controls.minDistance = 1.0;
    // controls.maxDistance = 10.0;

    let animate = function() {
      requestAnimationFrame(animate);
      render();
    };

    // animate();
    render();
  };

  let onInit = function() {
    for (let id of['euler-x', 'euler-y', 'euler-z']) {
      $(`#${id}`).on('input', onEulerChange);
    }

    for (let id of['quaternion-x', 'quaternion-y', 'quaternion-z', 'quaternion-w']) {
      $(`#${id}`).on('input', onQuaternionChange);
    }

    for (let id of['angle-axis-x', 'angle-axis-y', 'angle-axis-z', 'angle-axis-theta']) {
      $(`#${id}`).on('input', onAngleAxisChange);
    }

    for (let row = 0; row < 3; ++row)
      for (let col = 0; col < 3; ++col) {
        $(`#m${row}${col}`).on('input', onRotationMatrixChange);
      }

    updateViewFrom('init');

    // Enable popover on all the elements whose id ends with "-popover"
    // Automatically set their content to a hidden div with the
    // corresponding suffix "-popover-content".
    $("a[id*=-popover]").each(function() {
      let itemId = $(this).attr('id');
      $(this).popover({
        html: true,
        content: function() {
          return $(`#${itemId}-content`).html();
        }
      });
    });

    createWebGLScene();
  }

  $(document).ready(onInit);
</script>

<body>

  <div class="container">
    <div class="row">
      <div class="col bg-1-1">
        <div class="page-header">
          <h1 class="text-center">3D Rotation Conversion - \(B from A\)</h1>
        </div>
      </div>
    </div>

    <div class="flex-row row bg-1-2">
      <div class="col-xs-24">
        <p>
          We are considering the rotation that goes from a coordinate system \(A\) to a coordinate system \(B\), noted \(BfromA\). This notation allows to combine transforms without ambiguity, e.g \(BfromC = BfromA * AfromC\), and applies naturally to a point on
          the right: \(pointInB = BfromA * pointInA\)
        </p>
      </div>
    </div>

    <div class="flex-row row">
      <div class="col col-xs-24 col-sm-8 col-md-5 bg-4-1">
        <p>
          <h4 class="text-center">Euler Angles</h4>
        </p>
        <p class="text-center">
          <a title="Euler Angles" id="euler-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="euler-popover-content" class="hide">
          <p>
            Here they are defined in the Z-Y-X order,
            <a href="https://en.wikipedia.org/wiki/Euler_angles#Tait.E2.80.93Bryan_angles">Tait-Bryan</a>, Intrinsics.
            <br> \[BfromA = R(Z) * R(Y) * R(X)\] This means that a point gets transformed by first applying the rotation around X, then around the new Y, then around the new Z.
            <br><br> If you are trying to simulate the transform with your fingers, don't forget that applying these angles in sequence will make your finger-axes go from B to A, not from A to B!
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-z" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-8 col-md-5 bg-4-2 text-center">
        <p>
          <h4 class="text-center">Angle Axis</h4>
        </p>
        <p class="text-center">
          <a title="Angle Axis" id="angle-axis-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="angle-axis-popover-content" class="hide">
          <p>
            The rotation is uniquely defined (up to the sign) by a unit axis [X,Y,Z] and an angle &Theta; around it.
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-z" value="" /></td>
          </tr>
          <tr>
            <td>&Theta; = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-theta" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-8 col-md-5 bg-3-1">
        <p>
          <h4 class="text-center">Quaternion</h4>
        </p>
        <p class="text-center">
          <a title="Quaternion" id="quaternion-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="quaternion-popover-content" class="hide">
          <p>
            A unit quaternion is a unique (up to the sign) representation. Quaternions allow easy interpolation and composition.
            <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">See the wikipedia page.</a>
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-z" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">W = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-w" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-24 col-md-9 bg-2-1">
        <p>
          <h4 class="text-center">Rotation matrix 3x3</h4>
        </p>
        <p class="text-center">
          <a id="rotation-matrix-popover" title="Rotation matrix" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="rotation-matrix-popover-content" class="hide">
          <p>
            Rotation matrices are 3x3. The <b>row vectors</b> are the coordinates of each axis of B expressed in A. The <b>columns vectors</b> are the coordinates of each axis of A expressed in B.
          </p>
        </div>
        <table class="table packed">
          <tbody id="rotation-matrix-table">
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m00" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m01" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m02" value="" /></td>
            </tr>
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m10" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m11" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m12" value="" /></td>
            </tr>
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m20" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m21" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m22" value="" /></td>
            </tr>
          </tbody>
        </table>
        <div id="matrix-vector-a-from-b">
          $$[X,Y,Z]_B = [Y, -Z, X]_A$$
        </div>
      </div>
    </div>

    <div class="flex-row row">
      <div class="col col-xs-24 bg-1-1 text-center" id="webgl-view">
      </div>
    </div>
  </div>

</body>

</html>