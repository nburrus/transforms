<!DOCTYPE html>
<html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<script src="js/jquery.min.js"></script>
<script src="js/three.min.js"></script>
<script src="js/TrackballControls.js"></script>
<script src="js/bootstrap.min.js"></script>

<!-- Generated through https://www.bootstrap-live-customizer.com/ .
     First selecting the Cosmo theme. -->
<link rel="stylesheet" href="bootstrap.min.css">

<style>
  /* Remove the spinner buttons on number input fields */
  
  input[type="number"]::-webkit-outer-spin-button,
  input[type="number"]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  
  input[type="number"] {
    -moz-appearance: textfield;
    text-align: center;
  }
  
  .math {
    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;
    font-style: italic;
  }
  
  .mathDisplay {
    display: block;
    text-align: center;
    font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;
    font-style: italic;
    font-weight: bold;
    margin-bottom: 10px;
    white-space: nowrap;
  }
  /* Fixed size for our pretty float */
  
  .form-control.prettyFloat {
    display: inline-flex;
    margin-right: 0em;
    width: 6.5em;
  }
  
  .page-header {
    margin-top: 1em;
    margin-bottom: 1em;
  }
  
  .table.packed {
    width: auto;
    margin: 1em auto;
  }
  
  .table.packed td {
    vertical-align: middle;
    padding: 0;
    border: none;
  }
  
  .table.packed td.pr-2 {
    padding-right: 0.2em;
  }
  
  .row {
    background-color: #e2e9e9;
  }
  
  .row.bg-1-2 {
    background-color: #7e9a9a;
  }
  /* This is here to make all the columns have the same height. */
  
  @media only screen and (min-width: 481px) {
    .flex-row.row {
      display: flex;
      flex-wrap: wrap;
    }
    .flex-row.row>[class*='col-'] {
      display: flex;
      flex-direction: column;
    }
    .flex-row.row:after,
    .flex-row.row:before {
      display: flex;
    }
  }
  
  .hide {
    display: none;
  }
  
  .col.bg-1-1 {
    background-color: #e2e9e9;
  }
  
  .col.bg-1-2 {
    background-color: #7e9a9a;
  }
  
  .col.bg-2-1 {
    background-color: #ffebcc;
  }
  
  .col.bg-2-2 {
    background-color: #f6d8ac;
  }
  
  .col.bg-2-1 {
    background-color: #ffb84d;
  }
  
  .col.bg-2-2 {
    background-color: #db9833;
  }
  
  .col.bg-3-1 {
    background-color: #40a5f2;
  }
  
  .col.bg-3-2 {
    background-color: #2a6592;
  }
  
  .col.bg-4-1 {
    background-color: #cce9ff;
  }
  
  .col.bg-4-2 {
    background-color: #8ec3eb;
  }
  
  .help-tip {
    display: inline-block;
    text-align: center;
    background-color: #aaaaaa;
    border-radius: 50%;
    width: 32px;
    height: 32px;
    font-size: 16px;
    line-height: 32px;
    font-weight: bold;
    color: #fff;
    cursor: default;
  }
  
  .help-tip:hover {
    background: #fff;
    color: #aaaaaa;
  }
  
  .webgl-view {
    margin: 1em 0em;
  }
</style>

<script type="application/javascript">
  var state = {};
  state.bFromA = new THREE.Matrix4(); // the transform
  var glView = undefined;

  let matrixIndex = (r, c) => {
    return c * 4 + r;
  }
  let prettyFloat = (f) => {
    return Math.round(f * 1e5) / 1e5;
  }
  let rad2deg = (v) => {
    return v * 180.0 / Math.PI;
  }
  let deg2rad = (v) => {
    return v * Math.PI / 180.0;
  }
  let floatOrZero = (id) => {
    let v = document.getElementById(id).value;
    return v ? parseFloat(v) : 0.0;
  };

  let updateRotationMatrixView = function() {

    let elmToStr = (row, col) => {
      let v = state.bFromA.elements[matrixIndex(row, col)];
      return prettyFloat(v);
    };

    // Elements are stored in col-major mode, 4x4 matrix.        
    for (let row = 0; row < 3; ++row)
      for (let col = 0; col < 3; ++col) {
        let htmlValue = elmToStr(row, col);
        let htmlId = `#m${row}${col}`;
        $(htmlId).val(htmlValue);
      }
  };

  let updateRotationMatrixVectorConversion = function() {

    let isRotation = () => {
      // Check if it's a rotation.
      let q = new THREE.Quaternion();
      q.setFromRotationMatrix(state.bFromA);
      let newMat = new THREE.Matrix4();
      newMat.makeRotationFromQuaternion(q);

      for (let row = 0; row < 3; ++row) {
        for (let col = 0; col < 3; ++col) {
          let htmlId = `m${row}${col}`;
          if (Math.abs(newMat.elements[matrixIndex(row, col)] - floatOrZero(htmlId)) > 1e-3) {
            return false;
          }
        }
      }

      return true;
    };

    if (!isRotation()) {
      $('#matrix-vector-a-from-b').html('<span class="mathDisplay">NOT A VALID ROTATION</span>');
      return;
    }

    let getRow = (rowIndex) => {
      return new THREE.Vector3(state.bFromA.elements[matrixIndex(rowIndex, 0)],
        state.bFromA.elements[matrixIndex(rowIndex, 1)],
        state.bFromA.elements[matrixIndex(rowIndex, 2)]);
    };

    let isPermutationWithEps = (row, eps) => {
      let numZeros = (Math.round(row.x / eps) == 0) +
        (Math.round(row.y / eps) == 0) +
        (Math.round(row.z / eps) == 0);
      return numZeros == 2;
    };

    let isPerfectPermutation = (row) => {
      return isPermutationWithEps(row, 1e-5);
    };

    let approxZeroThreshold = 0.2;

    let isApproxPermutation = (row) => {
      return isPermutationWithEps(row, approxZeroThreshold);
    };

    let row0 = getRow(0);
    let row1 = getRow(1);
    let row2 = getRow(2);

    let allPerfect = (isPerfectPermutation(row0) &&
      isPerfectPermutation(row1) &&
      isPerfectPermutation(row2));

    let allApprox = (isApproxPermutation(row0) &&
      isApproxPermutation(row1) &&
      isApproxPermutation(row2));

    if (!allApprox) {
      $('#matrix-vector-a-from-b').html('<span class="mathDisplay">not a permutation</span>');
      return;
    }

    let eqOrApproxEq = (allPerfect ? '=' : '\\approx');

    let getNonZeroName = (row) => {
      if (Math.abs(Math.abs(row.x) - 1.0) < approxZeroThreshold)
        return row.x < 0 ? '-X<sub>A</sub>' : 'X<sub>A</sub>';
      if (Math.abs(Math.abs(row.y) - 1.0) < approxZeroThreshold)
        return row.y < 0 ? '-Y<sub>A</sub>' : 'Y<sub>A</sub>';
      if (Math.abs(Math.abs(row.z) - 1.0) < approxZeroThreshold)
        return row.z < 0 ? '-Z<sub>A</sub>' : 'Z<sub>A</sub>';
    };

    let X_B = getNonZeroName(row0);
    let Y_B = getNonZeroName(row1);
    let Z_B = getNonZeroName(row2);

    let formula = $('#matrix-vector-a-from-b');

    formula.html(`<span class="mathDisplay">[X<sub>B</sub>, Y<sub>B</sub>, Z<sub>B</sub>] ${eqOrApproxEq} [${X_B}, ${Y_B}, ${Z_B}]</span>`);
  }

  let updateEulerView = function() {
    let eulerAngles = new THREE.Euler();
    eulerAngles.setFromRotationMatrix(state.bFromA, 'ZYX');
    $('#euler-x').val(prettyFloat(rad2deg(eulerAngles.x)));
    $('#euler-y').val(prettyFloat(rad2deg(eulerAngles.y)));
    $('#euler-z').val(prettyFloat(rad2deg(eulerAngles.z)));
  };

  let updateQuaternionView = function() {
    let q = new THREE.Quaternion();
    q.setFromRotationMatrix(state.bFromA);
    $('#quaternion-x').val(prettyFloat(q.x));
    $('#quaternion-y').val(prettyFloat(q.y));
    $('#quaternion-z').val(prettyFloat(q.z));
    $('#quaternion-w').val(prettyFloat(q.w));
  };

  let updateAngleAxisView = function() {
    let q = new THREE.Quaternion();
    q.setFromRotationMatrix(state.bFromA);
    let angle = 2.0 * Math.acos(q.w);
    let s = Math.sqrt(1 - q.w * q.w);
    let x, y, z;
    if (s < 0.001) { // test to avoid divide by zero, s is always positive due to sqrt
      // if s close to zero then direction of axis not important
      x = q.x; // if it is important that axis is normalised then replace with x=1; y=z=0;
      y = q.y;
      z = q.z;
    } else {
      x = q.x / s; // normalise axis
      y = q.y / s;
      z = q.z / s;
    }
    $('#angle-axis-x').val(prettyFloat(x));
    $('#angle-axis-y').val(prettyFloat(y));
    $('#angle-axis-z').val(prettyFloat(z));
    $('#angle-axis-theta').val(prettyFloat(rad2deg(angle)));
  };

  let updateViewFrom = function(from) {
    if (from != 'rotationMatrix') updateRotationMatrixView();
    if (from != 'eulerAngles') updateEulerView();
    if (from != 'quaternion') updateQuaternionView();
    if (from != 'angleAxis') updateAngleAxisView();
    updateRotationMatrixVectorConversion();
    if (glView)
      glView.updateGLAxes(state.bFromA);
  };

  let onRotationMatrixChange = function() {
    for (let row = 0; row < 3; ++row) {
      for (let col = 0; col < 3; ++col) {
        let htmlId = `m${row}${col}`;
        state.bFromA.elements[matrixIndex(row, col)] = floatOrZero(htmlId);
      }
    }

    updateViewFrom('rotationMatrix');
  };

  let onEulerChange = function() {
    let floatRadiansOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) * Math.PI / 180.0 : 0.0;
    };
    let euler = new THREE.Euler(floatRadiansOrZero("euler-x"), floatRadiansOrZero("euler-y"), floatRadiansOrZero("euler-z"), 'ZYX');
    state.bFromA.makeRotationFromEuler(euler);
    updateViewFrom('eulerAngles');
  };

  let onQuaternionChange = function() {
    let floatOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) : 0.0;
    };
    let q = new THREE.Quaternion(
      floatOrZero("quaternion-x"),
      floatOrZero("quaternion-y"),
      floatOrZero("quaternion-z"),
      floatOrZero("quaternion-w"));
    q.normalize();
    state.bFromA.makeRotationFromQuaternion(q);
    updateViewFrom('quaternion');
  };

  let onAngleAxisChange = function() {
    let floatOrZero = id => {
      let v = document.getElementById(id).value;
      return v ? parseFloat(v) : 0.0;
    };
    let q = new THREE.Quaternion();
    q.setFromAxisAngle(new THREE.Vector3(
        floatOrZero("angle-axis-x"),
        floatOrZero("angle-axis-y"),
        floatOrZero("angle-axis-z")),
      Math.PI * floatOrZero("angle-axis-theta") / 180.0);
    state.bFromA.makeRotationFromQuaternion(q);
    updateViewFrom('angleAxis');
  };

  class GLView {

    constructor(domIdName) {
      this.webglViewElement = $(domIdName);
      this.createScene();
      this.createViews();
      this.renderGLScene();
    }

    createViews() {
      this.views = [{
        left: 0,
        top: 0,
        width: 0.5,
        height: 1.0,
        specificObjects: [this.bGroup],
      }, {
        left: 0.5,
        top: 0,
        width: 0.5,
        height: 1.0,
        specificObjects: [this.aGroup],
      }];
    }

    updateGLAxes(bFromA) {
      let aFromB = new THREE.Matrix4();
      aFromB.getInverse(bFromA);
      this.axisBGroup.matrixAutoUpdate = false;
      this.axisBGroup.matrix = aFromB;
      this.renderGLScene();
    }

    renderGLScene() {
      for (let view of this.views) {
        let size = this.renderer.getSize();
        var left = Math.floor(size.width * view.left);
        var top = Math.floor(size.height * view.top);
        var width = Math.floor(size.width * view.width);
        var height = Math.floor(size.height * view.height);

        this.renderer.setViewport(left, top, width, height);
        this.renderer.setScissor(left, top, width, height);
        this.renderer.setScissorTest(true);

        view.specificObjects.forEach((obj) => {
          obj.visible = true;
        });

        this.renderer.render(this.scene, this.camera);

        view.specificObjects.forEach((obj) => {
          obj.visible = false;
        });
      }
    }

    // Not used, don't need an animation loop for now.
    animate() {
      requestAnimationFrame(animate);
      this.renderGLScene();
    };

    createScene() {
      this.scene = new THREE.Scene();
      this.scene.background = new THREE.Color(0xdddddd);

      let windowAspectRatio = 2.0 / 1; // window will have two viewports side by side
      let cameraAspectRatio = 1.0 / 1; // each viewport will be a square
      this.camera = new THREE.PerspectiveCamera(75, cameraAspectRatio, 0.1, 1000);

      this.scene.add(new THREE.AmbientLight(0x404040));
      let light = new THREE.DirectionalLight(0xffffff);
      light.position.set(0, 1, 0);
      this.scene.add(light);

      this.renderer = new THREE.WebGLRenderer({
        antialias: true
      });
      this.renderer.domElement.classList.add('webgl-view');
      this.renderer.setPixelRatio(window.devicePixelRatio);

      this.webglViewElement.append(this.renderer.domElement);

      let setRenderSize = () => {
        let newWidth = this.webglViewElement.width();
        this.renderer.setSize(newWidth, newWidth / windowAspectRatio);
      };

      $(window).on('resize', () => {
        setRenderSize();
        this.controls.handleResize();
        this.renderGLScene();
      });

      setRenderSize();

      this.bGroup = new THREE.Group();
      this.bGroup.visible = false; // start hidden, each view will toggle it.
      this.scene.add(this.bGroup);

      this.aGroup = new THREE.Group();
      this.aGroup.visible = false; // start hidden, each view will toggle it.
      this.scene.add(this.aGroup);

      this.axisBGroup = new THREE.Group();
      this.bGroup.add(this.axisBGroup);

      this.axisAGroup = new THREE.Group();
      this.aGroup.add(this.axisAGroup);

      let arrowDirAndColors = [{
        dir: new THREE.Vector3(1, 0, 0),
        color: 0xff0000
      }, {
        dir: new THREE.Vector3(0, 1, 0),
        color: 0x00ff00
      }, {
        dir: new THREE.Vector3(0, 0, 1),
        color: 0x0000ff
      }];

      arrowDirAndColors.forEach((params) => {
        let arrowA = new THREE.ArrowHelper(params.dir, new THREE.Vector3(0, 0, 0), 1.0, params.color);
        let arrowB = new THREE.ArrowHelper(params.dir, new THREE.Vector3(0, 0, 0), 1.0, params.color);
        this.axisAGroup.add(arrowA);
        this.axisBGroup.add(arrowB);
      });

      let createLabel = (group, name, x, y, z) => {
        let label = this._makeTextSprite(name);
        label.position.set(x, y, z);
        group.add(label);
        return label;
      };

      createLabel(this.axisAGroup, "X_A", 1.0, 0.05, 0.05);
      createLabel(this.axisAGroup, "Y_A", 0.05, 1.0, 0.05);
      createLabel(this.axisAGroup, "Z_A", 0.05, 0.05, 1.0);

      createLabel(this.axisBGroup, "X_B", 1.0, 0.05, 0.05);
      createLabel(this.axisBGroup, "Y_B", 0.05, 1.0, 0.05);
      createLabel(this.axisBGroup, "Z_B", 0.05, 0.05, 1.0);

      // aGroup.position.set(-1, 0.0, 0.0);
      // bGroup.position.set(1, 0.0, 0.0);

      this.camera.position.z = 2.;

      this.controls = new THREE.TrackballControls(this.camera, this.renderer.domElement);
      this.controls.addEventListener('change', () => this.renderGLScene());

      this.controls.rotateSpeed = 2.0;
      this.controls.noZoom = true;
      this.controls.noPan = true;
      this.controls.noRotate = false;
      this.controls.enableDamping = false; // don't need to animate this way
    }

    _makeTextSprite(message, parameters) {
      if (parameters === undefined) parameters = {};
      let fontface = parameters.hasOwnProperty("fontface") ? parameters["fontface"] : "Arial";
      let fontsize = parameters.hasOwnProperty("fontsize") ? parameters["fontsize"] : 24;
      let textColor = parameters.hasOwnProperty("textColor") ? parameters["textColor"] : {
        r: 0,
        g: 0,
        b: 0,
        a: 1.0
      };

      let canvas = document.createElement('canvas');
      canvas.width = 128;
      canvas.height = 64;
      var context = canvas.getContext('2d');
      context.font = "Bold " + fontsize + "px " + fontface;
      var metrics = context.measureText(message);
      var textWidth = metrics.width;

      context.fillStyle = "rgba(" + textColor.r + ", " + textColor.g + ", " + textColor.b + ", 1.0)";
      context.fillText(message, canvas.width / 2, canvas.height / 2);

      var texture = new THREE.Texture(canvas)
      texture.needsUpdate = true;

      var spriteMaterial = new THREE.SpriteMaterial({
        map: texture,
        depthTest: false,
        depthWrite: false
      });
      var sprite = new THREE.Sprite(spriteMaterial);
      let aspectRatio = canvas.width / canvas.height;
      sprite.scale.set(0.3 * aspectRatio, 0.3 * 1, 1);
      return sprite;
    };

  };

  let onInit = function() {
    for (let id of['euler-x', 'euler-y', 'euler-z']) {
      $(`#${id}`).on('input', onEulerChange);
    }

    for (let id of['quaternion-x', 'quaternion-y', 'quaternion-z', 'quaternion-w']) {
      $(`#${id}`).on('input', onQuaternionChange);
    }

    for (let id of['angle-axis-x', 'angle-axis-y', 'angle-axis-z', 'angle-axis-theta']) {
      $(`#${id}`).on('input', onAngleAxisChange);
    }

    for (let row = 0; row < 3; ++row)
      for (let col = 0; col < 3; ++col) {
        $(`#m${row}${col}`).on('input', onRotationMatrixChange);
      }

    updateViewFrom('init');

    // Enable popover on all the elements whose id ends with "-popover"
    // Automatically set their content to a hidden div with the
    // corresponding suffix "-popover-content".
    $("a[id*=-popover]").each(function() {
      let itemId = $(this).attr('id');
      $(this).popover({
        html: true,
        content: function() {
          return $(`#${itemId}-content`).html();
        }
      });
    });

    glView = new GLView('#webgl-view');
  }

  $(document).ready(onInit);
</script>

<body>

  <div class="container">
    <div class="row">
      <div class="col bg-1-1">
        <div class="page-header">
          <h1 class="text-center">3D Rotation Conversion - <span class="math">BfromA</span></h1>
        </div>
      </div>
    </div>

    <div class="flex-row row bg-1-2">
      <div class="col-xs-24">
        <p>
          We are considering the rotation that goes from a coordinate system <span class="math">A</span> to a coordinate system <span class="math">B</span>, noted <span class="math">BfromA</span>. This notation allows to combine transforms without ambiguity,
          e.g <span class="math">BfromC = BfromA * AfromC</span>, and applies naturally to a point on the right: <span class="math">pointInB = BfromA * pointInA</span>
        </p>
      </div>
    </div>

    <div class="flex-row row">
      <div class="col col-xs-24 col-sm-8 col-md-5 bg-4-1">
        <p>
          <h4 class="text-center">Euler Angles</h4>
        </p>
        <p class="text-center">
          <a title="Euler Angles" id="euler-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="euler-popover-content" class="hide">
          <p>
            Here they are defined in the Z-Y-X order,
            <a href="https://en.wikipedia.org/wiki/Euler_angles#Tait.E2.80.93Bryan_angles">Tait-Bryan</a>, Intrinsics.
            <p><span class="mathDisplay">BfromA = R(Z) * R(Y) * R(X)</span></p> This means that a point gets transformed by first applying the rotation around X, then around the new Y, then around the new Z.
            <br><br> If you are trying to simulate the transform with your fingers, don't forget that applying these angles in sequence will make your finger-axes go from B to A, not from A to B!
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="euler-z" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-8 col-md-5 bg-4-2 text-center">
        <p>
          <h4 class="text-center">Angle Axis</h4>
        </p>
        <p class="text-center">
          <a title="Angle Axis" id="angle-axis-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="angle-axis-popover-content" class="hide">
          <p>
            The rotation is uniquely defined (up to the sign) by a unit axis [X,Y,Z] and an angle &Theta; around it.
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-z" value="" /></td>
          </tr>
          <tr>
            <td>&Theta; = </td>
            <td><input type="number" class="form-control prettyFloat" id="angle-axis-theta" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-8 col-md-5 bg-3-1">
        <p>
          <h4 class="text-center">Quaternion</h4>
        </p>
        <p class="text-center">
          <a title="Quaternion" id="quaternion-popover" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="quaternion-popover-content" class="hide">
          <p>
            A unit quaternion is a unique (up to the sign) representation. Quaternions allow easy interpolation and composition.
            <a href="https://en.wikipedia.org/wiki/Quaternions_and_spatial_rotation">See the wikipedia page.</a>
          </p>
        </div>
        <table class="table packed">
          <tr>
            <td class="pr-2">X = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-x" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Y = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-y" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">Z = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-z" value="" /></td>
          </tr>
          <tr>
            <td class="pr-2">W = </td>
            <td><input type="number" class="form-control prettyFloat" id="quaternion-w" value="" /></td>
          </tr>
        </table>
        <br>
      </div>

      <div class="col col-xs-24 col-sm-24 col-md-9 bg-2-1">
        <p>
          <h4 class="text-center">Rotation matrix 3x3</h4>
        </p>
        <p class="text-center">
          <a id="rotation-matrix-popover" title="Rotation matrix" data-toggle="popover" data-trigger="click" data-placement="auto"><span class="help-tip">?</span></a>
        </p>
        <div id="rotation-matrix-popover-content" class="hide">
          <p>
            Rotation matrices are 3x3. The <b>row vectors</b> are the coordinates of each axis of B expressed in A. The <b>columns vectors</b> are the coordinates of each axis of A expressed in B.
          </p>
        </div>
        <table class="table packed">
          <tbody id="rotation-matrix-table">
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m00" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m01" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m02" value="" /></td>
            </tr>
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m10" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m11" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m12" value="" /></td>
            </tr>
            <tr>
              <td><input type="number" class="form-control prettyFloat" id="m20" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m21" value="" /></td>
              <td><input type="number" class="form-control prettyFloat" id="m22" value="" /></td>
            </tr>
          </tbody>
        </table>
        <div id="matrix-vector-a-from-b">
          $$[X,Y,Z]_B = [Y, -Z, X]_A$$
        </div>
      </div>
    </div>

    <div class="flex-row row">
      <div class="col-md-6 bg-1-1"></div>
      <div class="col-xs-24 col-md-12 bg-1-1" id="webgl-view"></div>
      <div class="col-md-6 bg-1-1"></div>
    </div>
  </div>

</body>

</html>